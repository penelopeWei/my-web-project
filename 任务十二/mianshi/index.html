<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title></title>
    <link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="css/baidu.css">
</head>

<body>
    <div class="container">
        <table class="table table-bordered" style="word-break:break-all; word-wrap:break-all; margin:40px;">
            <tbody>
                <tr class="active">
                    <td colspan="" class="col-md-2" rowspan="" headers="">position的值， relative和absolute分别是相对于谁进行定位的？</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">
                        absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。
                        <br/> fixed （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。
                        <br/> relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。
                        <br/> static 默认值。没有定位，元素出现在正常的流中
                        <br/> sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出
                        <br/>
                    </td>
                </tr>
                <tr class="success">
                    <td colspan="" class="col-md-2" rowspan="" headers="">如何解决跨域问题</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">JSONP：
                        <br/>原理是：动态插入 script 标签，通过 script 标签引入一个 js 文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的 json 数据作为参数传入。
                        <br/> 由于同源策略的限制， XmlHttpRequest 只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过 script 标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。
                        <br/> 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。
                        <br/> JSONP ： json+padding （内填充），顾名思义，就是把JSON填充到一个盒子里
                        <br/>
                        <br/> CORS
                        <br/> 服务器端对于 CORS 的支持，主要就是通过设置 Access-Control-Allow-Origin 来进行的。如果浏览器检测到相应的设置，就可以允许 Ajax 进行跨域的访问。
                        <br/> 通过修改document.domain来跨子域
                        <br/> 将子域和主域的 document.domain 设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用 document.domain 进行跨域
                        <br/> 主域相同的使用 document.domain
                        <br/> 使用window.name来进行跨域
                        <br/> window 对象有个 name 属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限， window.name 是持久存在一个窗口载入过的所有页面中的
                        <br/> 使用HTML5中新引进的 window.postMessage 方法来跨域传送数据
                        <br/> 还有flash、在服务器上设置代理页面等跨域方式。个人认为 window.name 的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。
                        <br/>
                    </td>
                </tr>
                <tr class="warning">
                    <td colspan="" class="col-md-2" rowspan="" headers="">XML 和 JSON 的区别？</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">(1).数据体积方面。 JSON相对于XML来讲，数据的体积小，传递的速度更快些。
                        <br/> (2).数据交互方面。
                        <br/> JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
                        <br/> (3).数据描述方面。
                        <br/> JSON对数据的描述性比XML较差。
                        <br/> (4).传输速度方面。
                        <br/> JSON的速度要远远快于XML。
                        <br/>
                    </td>
                </tr>
                <tr class="danger">
                    <td colspan="" class="col-md-2" rowspan="" headers="">谈谈你对webpack的看法</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">
                        WebPack 是一个模块打包工具，你可以使用 WebPack 管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的 HTML、JavaScript、CSS 以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源， webpack 有对应的模块加载器。 webpack 模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。
                        <br/> webpack 的两大特色：
                        <br/> 1.code splitting（可以自动完成）
                        <br/> 2.loader 可以处理各种类型的静态文件，并且支持串联操作
                        <br/> webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。
                        <br/> webpack 具有 requireJs 和 browserify 的功能，但仍有很多自己的新特性：
                        <br/> 1. 对 CommonJS 、 AMD 、ES6的语法做了兼容
                        <br/> 2. 对js、css、图片等资源文件都支持打包
                        <br/> 3. 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持
                        <br/> 4. 有独立的配置文件webpack.config.js
                        <br/> 5. 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间
                        <br/> 6. 支持 SourceUrls 和 SourceMaps，易于调试
                        <br/> 7. 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活
                        <br/> 8.webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快
                        <br/>
                    </td>
                </tr>
                <tr class="active">
                    <td colspan="" class="col-md-2" rowspan="" headers="">说说TCP传输的三次握手四次挥手策略</td>
                    <td colspan="" class="col-md-10" rowspan="" headers=""> 为了准确无误地把数据送达目标处， TCP 协议采用了三次握手策略。用TCP协议把数据包送出去后， TCP 不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志： SYN 和 ACK 。
                        <br/>
                        <br/> 发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。 最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断， TCP 协议会再次以相同的顺序发送相同的数据包。
                        <br/>
                        <br/> 断开一个TCP连接则需要“四次握手”：
                        <br/> 第一次挥手：主动关闭方发送一个 FIN ，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。
                        <br/> 第二次挥手：被动关闭方收到 FIN 包后，发送一个 ACK 给对方，确认序号为收到序号 +1 （与 SYN 相同，一个 FIN 占用一个序号）。
                        <br/> 第三次挥手：被动关闭方发送一个 FIN ，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
                        <br/> 第四次挥手：主动关闭方收到 FIN 后，发送一个 ACK 给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。
                        <br/>
                    </td>
                </tr>
                <tr class="success">
                    <td colspan="" class="col-md-2" rowspan="" headers="">TCP和UDP的区别</td>
                    <td colspan="" class="col-md-10" rowspan="" headers=""> TCP
                        <br/>（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次“对话”才能建立起来
                        <br/>
                        <br/> UDP
                        <br/>（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</td>
                </tr>
                <tr class="warning">
                    <td colspan="" class="col-md-2" rowspan="" headers=""> 说说你对作用域链的理解</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到 window 对象即被终止，作用域链向下访问变量是不被允许的。</td>
                </tr>
                <tr class="danger">
                    <td colspan="" class="col-md-2" rowspan="" headers="">创建ajax过程</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.
                        <br/> (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.
                        <br/> (3)设置响应HTTP请求状态变化的函数.
                        <br/> (4)发送HTTP请求.
                        <br/> (5)获取异步调用返回的数据.
                        <br/> (6)使用JavaScript和DOM实现局部刷新.
                        <br/>
                    </td>
                </tr>
                <tr class="active">
                    <td colspan="" class="col-md-2" rowspan="" headers=""> 渐进增强和优雅降级</td>
                    <td colspan="" class="col-md-10" rowspan="" headers=""> 渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
                        <br/> 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</td>
                </tr>
                <tr class="success">
                    <td colspan="" class="col-md-2" rowspan="" headers="">HTTP和HTTPS</td>
                    <td colspan="" class="col-md-10" rowspan="" headers=""> HTTP 协议通常承载于TCP协议之上，在 HTTP 和 TCP 之间添加一个安全协议层（ SSL 或 TSL ），这个时候，就成了我们常说的HTTPS。
                        <br/> 默认HTTP的端口号为80， HTTPS 的端口号为443。</td>
                </tr>
                <tr class="warning">
                    <td colspan="" class="col-md-2" rowspan="" headers="">为什么 HTTPS 安全</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用 HTTPS ，密钥在你和终点站才有。 https 之所以比 http 安全，是因为他利用 ssl/tls 协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性</td>
                </tr>
                <tr class="danger">
                    <td colspan="" class="col-md-2" rowspan="" headers=""> 对前端模块化的认识</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">
                        AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
                        <br/> CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。
                        <br/> AMD 是提前执行， CMD 是延迟执行。
                        <br/> AMD 推荐的风格通过返回一个对象做为模块对象， CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的。
                        <br/> CMD模块方式
                        <br/> define(function(require, exports, module) {
                        <br/> // 模块代码
                        <br/> });
                    </td>
                </tr>
                <tr class="active">
                    <td colspan="" class="col-md-2" rowspan="" headers="">Javascript垃圾回收方法</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">
                        标记清除（mark and sweep）
                        <br/> 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。
                        <br/> 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了
                        <br/> 引用计数(reference counting)
                        <br/> 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个
                        <br/>变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。
                        <br/> 在IE中虽然 JavaScript 对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及 BOM 及DOM就会出现循环引用问题。
                        <br/>
                    </td>
                </tr>
                <tr class="success">
                    <td colspan="" class="col-md-2" rowspan="" headers=""> 谈谈性能优化问题</td>
                    <td colspan="" class="col-md-10" rowspan="" headers=""> 代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。
                        <br/> 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等
                        <br/> 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。
                        <br/> 请求带宽：压缩文件，开启GZIP，
                        <br/> 代码层面的优化
                        <br/> 用 hash-table 来优化查找
                        <br/> 少用全局变量
                        <br/> 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能
                        <br/> 用 setTimeout 来避免页面失去响应
                        <br/> 缓存DOM节点查找的结果
                        <br/> 避免使用CSS Expression
                        <br/> 避免全局查询
                        <br/> 避免使用with(with会创建自己的作用域，会增加作用域链长度)
                        <br/> 多个变量声明合并
                        <br/> 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率
                        <br/> 尽量避免写在HTML标签中写Style属性
                    </td>
                </tr>
                <tr class="warning">
                    <td colspan="" class="col-md-2" rowspan="" headers="">移动端性能优化</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">
                        尽量使用css3动画，开启硬件加速。
                        <br/> 适当使用 touch 事件代替 click 事件。
                        <br/> 避免使用 css3 渐变阴影效果。
                        <br/> 可以用 transform: translateZ(0) 来开启硬件加速。
                        <br/> 不滥用Float。Float在渲染时计算量比较大，尽量减少使用
                        <br/> 不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。
                        <br/> 合理使用requestAnimationFrame动画代替setTimeout CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加
                        <br/> PC端的在移动端同样适用
                    </td>
                </tr>
                <tr class="danger">
                    <td colspan="" class="col-md-2" rowspan="" headers="">栈和队列的区别?</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。
                        <br/> 队列先进先出，栈先进后出。
                        <br/> 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除
                        <br/>
                    </td>
                </tr>
                <tr class="active">
                    <td colspan="" class="col-md-2" rowspan="" headers="">栈和堆的区别？</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。
                        <br/> 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。
                        <br/> 堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
                        <br/> 栈（数据结构）：一种先进后出的数据结构。
                        <br/>
                    </td>
                </tr>
                <tr class="success">
                    <td colspan="" class="col-md-2" rowspan="" headers="">ES6的了解</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值 Inputs=>outputs 。）、for-of （用来遍历数据—例如数组中的值。） arguments 对象可被不定参数和默认参数完美代替。 ES6 将 promise 对象纳入规范，提供了原生的 Promise 对象。增加了 let 和 const 命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定， var 命令和 function 命令声明的全局变量，属于全局对象的属性； let 命令、 const 命令、 class 命令声明的全局变量，不属于全局对象的属性。。还有就是引入 module 模块的概念</td>
                </tr>
                <tr class="warning">
                    <td colspan="" class="col-md-2" rowspan="" headers="">js继承方式及其优缺点</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">
                        原型链继承的缺点
                        <br/> 一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。
                        <br/> 借用构造函数（类式继承）
                        <br/> 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承
                        <br/> 组合式继承
                        <br/> 组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。
                        <br/>
                    </td>
                </tr>
                <tr class="danger">
                    <td colspan="" class="col-md-2" rowspan="" headers=""> 谈谈浮动和清除浮动</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。</td>
                </tr>
                <tr class="active">
                    <td colspan="" class="col-md-2" rowspan="" headers="">如何评价AngularJS和BackboneJS</td>
                    <td colspan="" class="col-md-10" rowspan="" headers=""> backbone 具有依赖性，依赖 underscore.js 。 Backbone + Underscore + jQuery(or Zepto) 就比一个 AngularJS 多出了2 次HTTP请求.
                        <br/> Backbone 的 Model 没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。 AngularJS 与此相反，Model直接与UI视图绑定， Model 与UI视图的关系，通过 directive 封装， AngularJS 内置的通用 directive ，就能实现大部分操作了，也就是说，基本不必关心 Model 与UI视图的关系，直接操作Model就行了，UI视图自动更新。
                        <br/> AngularJS 的 directive ，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令。
                        <br/> </td>
                </tr>
                <tr class="success">
                    <td colspan="" class="col-md-2" rowspan="" headers=""> 浏览器本地存储</td>
                    <td colspan="" class="col-md-10" rowspan="" headers=""> 在较高版本的浏览器中， js 提供了 sessionStorage 和 globalStorage 。在HTML5 中提供了 localStorage 来取代 globalStorage 。
                        <br/> html5 中的 Web Storage 包括了两种存储方式： sessionStorage 和 localStorage 。
                        <br/> sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。
                        <br/> 而 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</td>
                </tr>
                <tr class="warning">
                    <td colspan="" class="col-md-2" rowspan="" headers="">web storage和cookie的区别</td>
                    <td colspan="" class="col-md-10" rowspan="" headers=""> Web Storage 的概念和 cookie 相似，区别是它是为了更大容量存储设计的。 Cookie 的大小是受限的，并且每次你请求一个新的页面的时候 Cookie 都会被发送过去，这样无形中浪费了带宽，另外 cookie 还需要指定作用域，不可以跨域调用。
                        <br/> 除此之外， Web Storage 拥有 setItem,getItem,removeItem,clear 等方法，不像 cookie 需要前端开发者自己封装 setCookie，getCookie 。
                        <br/> 但是 cookie 也是不可以或缺的： cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地“存储”数据而生
                        <br/> 浏览器的支持除了 IE７ 及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的 userData 其实就是 javascript 本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持 web storage 。
                        <br/> localStorage 和 sessionStorage 都具有相同的操作方法，例如 setItem、getItem 和 removeItem 等</td>
                </tr>
                <tr class="danger">
                    <td colspan="" class="col-md-2" rowspan="" headers="">cookie 和session 的区别：</td>
                    <td colspan="" class="col-md-10" rowspan="" headers=""> 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
                        <br/> 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
                        <br/> 考虑到安全应当使用session。
                        <br/> 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
                        <br/> 5、所以个人建议：
                        <br/> 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中
                    </td>
                </tr>
                <tr class="active">
                    <td colspan="" class="col-md-2" rowspan="" headers="">HTML与XHTML——二者有什么区别</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">区别：
                        <br/> 1.所有的标记都必须要有一个相应的结束标记
                        <br/> 2.所有标签的元素和属性的名字都必须使用小写
                        <br/>
                        <br/> 3.所有的XML标记都必须合理嵌套
                        <br/> 4.所有的属性必须用引号""括起来
                        <br/> 5.把所有
                        <和&特殊符号用编码表示 <br/> 6.给所有属性赋一个值
                        <br/> 7.不要在注释内容中使“--”
                        <br/> 8.图片必须有说明文字
                    </td>
                </tr>
                <tr class="success">
                    <td colspan="" class="col-md-2" rowspan="" headers="">解释下浮动和它的工作原理？清除浮动的技巧</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 1.使用空标签清除浮动。
                        <br/> 这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。
                        <br/> 2.使用overflow。
                        <br/> 给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。
                        <br/> 3.使用after伪对象清除浮动。
                        <br/> 该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；
                        <br/>
                    </td>
                </tr>
                <tr class="warning">
                    <td colspan="" class="col-md-2" rowspan="" headers="">null和undefined的区别？</td>
                    <td colspan="" class="col-md-10" rowspan="" headers=""> null 是一个表示"无"的对象，转为数值时为0； undefined 是一个表示"无"的原始值，转为数值时为 NaN 。
                        <br/> 当声明的变量还未被初始化时，变量的默认值为 undefined 。
                        <br/> null 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。
                        <br/> undefined 表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：
                        <br/> （1）变量被声明了，但没有赋值时，就等于undefined。
                        <br/> （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
                        <br/> （3）对象没有赋值的属性，该属性的值为undefined。
                        <br/> （4）函数没有返回值时，默认返回undefined。
                        <br/> null 表示"没有对象"，即该处不应该有值。典型用法是：
                        <br/> （1） 作为函数的参数，表示该函数的参数不是对象。
                        <br/> （2） 作为对象原型链的终点。
                        <br/>
                    </td>
                </tr>
                <tr class="danger">
                    <td colspan="" class="col-md-2" rowspan="" headers="">js延迟加载的方式有哪些？</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js
                        <br/> call() 和 apply() 的区别和作用？
                        <br/> 作用：动态改变某个类的某个方法的运行环境（执行上下文）。
                        <br/>
                    </td>
                </tr>
                <tr class="active">
                    <td colspan="" class="col-md-2" rowspan="" headers="">new操作符具体干了什么呢?</td>
                    <td colspan="" class="col-md-10" rowspan="" headers=""> 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
                        <br/> 2、属性和方法被加入到 this 引用的对象中。
                        <br/> 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。
                        <br/>
                    </td>
                </tr>
                <tr class="success">
                    <td colspan="" class="col-md-2" rowspan="" headers="">哪些操作会造成内存泄漏？</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
                        <br/> 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。
                        <br/> setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
                        <br/> 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
                        <br/>
                    </td>
                </tr>
                <tr class="warning">
                    <td colspan="" class="col-md-2" rowspan="" headers="">列举IE 与其他浏览器不一样的特性？</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">
                        IE支持 currentStyle ，FIrefox使用 getComputStyle
                        <br/> IE 使用 innerText ，Firefox使用 textContent
                        <br/> 滤镜方面：IE: filter:alpha(opacity= num) ；Firefox： -moz-opacity:num
                        <br/> 事件方面：IE： attachEvent ：火狐是 addEventListener
                        <br/> 鼠标位置：IE是 event.clientX ；火狐是 event.pageX
                        <br/> IE使用 event.srcElement ；Firefox使用 event.target
                        <br/> IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置 margin:0;padding:0以及list-style:none
                        <br/> CSS圆角：ie7以下不支持圆角
                        <br/>
                    </td>
                </tr>
                <tr class="danger">
                    <td colspan="" class="col-md-2" rowspan="" headers="">WEB应用从服务器主动推送Data到客户端有那些方式？</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">
                        Javascript数据推送
                        <br/> Commet ：基于HTTP长连接的服务器推送技术
                        <br/> 基于 WebSocket 的推送方案
                        <br/> SSE （Server-Send Event）：服务器推送数据新方式
                        <br/>
                    </td>
                </tr>
                <tr class="active">
                    <td colspan="" class="col-md-2" rowspan="" headers="">javascript对象的几种创建方式</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">1，工厂模式
                        <br/>
                        <br/> 2，构造函数模式
                        <br/> 3，原型模式
                        <br/> 4，混合构造函数和原型模式
                        <br/> 5，动态原型模式
                        <br/> 6，寄生构造函数模式
                        <br/> 7，稳妥构造函数模式
                        <br/>
                    </td>
                </tr>
                <tr class="success">
                    <td colspan="" class="col-md-2" rowspan="" headers="">javascript继承的6种方法</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">
                        1，原型链继承
                        <br/> 2，借用构造函数继承
                        <br/> 3，组合继承(原型+借用构造)
                        <br/> 4，原型式继承
                        <br/> 5，寄生式继承
                        <br/> 6，寄生组合式继承
                        <br/>
                    </td>
                </tr>
                <tr class="warning">
                    <td colspan="" class="col-md-2" rowspan="" headers="">异步加载和延迟加载</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">1.异步加载的方案： 动态插入script标签
                        <br/> 2.通过ajax去获取js代码，然后通过eval执行
                        <br/> 3.script标签上添加defer或者async属性
                        <br/> 4.创建并插入iframe，让它异步执行js
                        <br/> 5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。
                        <br/>
                    </td>
                </tr>
                <tr class="danger">
                    <td colspan="" class="col-md-2" rowspan="" headers="">Flash 、 Ajax 各自的优缺点，在使用中如何取舍？</td>
                    <td colspan="" class="col-md-10" rowspan="" headers="">
                        Flash 适合处理多媒体、矢量图形、访问机器；对 CSS 、处理文本上不足，不容易被搜索。
                        <br/> - Ajax 对 CSS 、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
                        <br/> 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
                    </td>
                    <br/>
                </tr>
                <tr class="active">
                    <td colspan="" class="col-md-2" rowspan="" headers="">GET和POST的区别，何时使用POST？</td>
                    <td colspan="" class="col-md-10" rowspan="" headers=""> GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符
                        <br/> POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
                        <br/> GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，
                        <br/> 也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
                        <br/> 然而，在以下情况中，请使用 POST 请求：
                        <br/> 无法使用缓存文件（更新服务器上的文件或数据库）
                        <br/> 向服务器发送大量数据（POST 没有数据量限制）
                        <br/> 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</td>
                </tr>
               
            </tbody>
        </table>
    </div>
    <script type="text/javascript " src="js/jquery-3.1.1.min.js "></script>
    <script type="text/javascript " src="js/index.js "></script>
</body>

</html>
